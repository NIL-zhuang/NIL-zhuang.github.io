<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>SE - Category - 抓鱼 zzy's Blog</title><link>https://nil-zhuang.github.io/categories/se/</link><description>SE - Category - 抓鱼 zzy's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ziyuan.zhuang@smail.nju.edu.cn (Nil Zhuang)</managingEditor><webMaster>ziyuan.zhuang@smail.nju.edu.cn (Nil Zhuang)</webMaster><copyright>Ziyuan Zhuang 2022</copyright><lastBuildDate>Wed, 25 Jan 2023 16:21:21 +0800</lastBuildDate><atom:link href="https://nil-zhuang.github.io/categories/se/" rel="self" type="application/rss+xml"/><item><title>设计模式-以深度学习为例-创建型模式</title><link>https://nil-zhuang.github.io/2023/01/design_pattern_dl_generator/</link><pubDate>Wed, 25 Jan 2023 16:21:21 +0800</pubDate><author>nil zhuang</author><guid>https://nil-zhuang.github.io/2023/01/design_pattern_dl_generator/</guid><description><![CDATA[<div class="featured-image">
                <img src="https://lemonzzy.oss-cn-hangzhou.aliyuncs.com/typora/202301251625395.png" referrerpolicy="no-referrer">
            </div><h1 id="设计模式---以深度学习为例---创建型模式">设计模式 - 以深度学习为例 - 创建型模式</h1>
<p>在 <a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener noreffer ">常用设计模式</a> 中，介绍了一系列创建型模式、结构型模式和行为模式的设计模式，对日常代码质量提升有很大帮助。但它们往往以 JAVA 语言的工程项目为例，我们在这里以深度学习的模型搭建、训练、推理、部署为例，解释面向对象编程中 22 中设计模式的基本原理。</p>
<p>设计模式分为</p>
<ul>
<li>创建型模式：工厂方法，抽象工厂，生成器，原型，单例</li>
<li>结构型模式：适配器，桥接，组合，装饰，外观，享元，代理</li>
<li>行为模式：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模板方法，访问者</li>
</ul>
<p>本文介绍创建型模式在深度学习中的应用。创建型模式提供创建对象的机制，能够提升已有代码的灵活性和可复用性。</p>
<hr>
<h2 id="工厂方法-factory-method">工厂方法 Factory Method</h2>
<p>工厂方法在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。
</p>
<ul>
<li>产品 Product 对接口进行声明，对于创建者或者由其子类构建的对象，接口是通用的</li>
<li>创建者类声明返回 Product 对象的工厂方法，返回类型和产品接口相匹配</li>
</ul>
<h3 id="使用场景">使用场景</h3>
<ol>
<li>将产品的创建与实际的使用分离 → 只需要开发新的 ConcreteCreator，重写其 <code>createProduct</code> 方法。</li>
<li>利用继承扩展软件库和框架默认行为</li>
</ol>
<h3 id="效果">效果</h3>
<ol>
<li>避免创建者和具体产品之间的耦合</li>
<li>单一职责原则，将产品创建代码放在程序的单一位置，使代码更易维护</li>
<li>开闭原则，无需修改现有客户端代码，就可以引入新的产品类型</li>
<li>但是工厂方法会引入很多新的子类，代码变得复杂</li>
</ol>
<h3 id="深度学习例子">深度学习例子</h3>
<p>例如我们在整合模型到同一个框架中，其一是自回归模型 Transformer，其二是对抗网络 GAN，二者的结构不同，所以训练过程差异很大。Transformer 只有一个模型，而 GAN 包含了 Generator 和 Discriminator。但同时，两个任务有相同的超参初始化，checkpoint 保存，数据集读取等任务。</p>
<p>在模型构建中，我们有一个公共 Product <code>nn.Module</code>，基于此构建了 <code>Transformer</code> 和 <code>GAN</code> 两个具体产品。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Transformer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Transformer&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GAN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;GAN&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在模型训练中，我们使用一个公共方法 <code>Trainer</code>，包含了 <code>build_model</code> 方法来创建相应的模型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Trainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_model</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># train the model</span>
</span></span><span class="line"><span class="cl">        <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GANTrainer</span><span class="p">(</span><span class="n">Trainer</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_model</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GAN</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TransformerTrainer</span><span class="p">(</span><span class="n">Trainer</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_model</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Transformer</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在实际使用中，通过调用 trainer 的模型训练接口，就可以实现训练。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">train_my_model</span><span class="p">(</span><span class="n">trainer</span><span class="p">:</span><span class="n">Trainer</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">trainer</span><span class="o">.</span><span class="n">train_model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="抽象工厂-abstract-factory">抽象工厂 Abstract Factory</h2>
<p></p>
<ul>
<li>抽象产品 Abstract Product 是构成系列产品的不同但相关的产品声明接口</li>
<li>抽象工厂 Abstract Factory 接口声明一组创建抽象产品的方法</li>
<li>具体工厂会对具体产品初始化，但构造方法的签名必须返回相应的抽象产品。客户端只需要调用抽象接口就能返回相应的抽象产品，客户端代码就不会和工厂创建的特定产品变体耦合。</li>
</ul>
<h3 id="使用场景-1">使用场景</h3>
<ul>
<li>代码需要和多个不同序列的相关产品交互，不希望代码基于产品的具体类进行构建</li>
<li>有一个基于 <strong>一组抽象方法</strong> 的类抽象工厂提供一个接口来创建每个系列产品的对象</li>
<li>以不同的产品类型变体维度绘制矩阵 → 为所有产品声明抽象产品接口，让具体产品实现具体接口 → 声明抽象工厂接口，每个具体工厂实现接口 → 将代码中产品构造函数替换成工厂方法的构造函数</li>
</ul>
<h3 id="效果-1">效果</h3>
<ul>
<li>单一职责原则 &amp; 开闭原则</li>
<li>引入多种接口和类，代码变复杂</li>
</ul>
<h3 id="深度学习例子-1">深度学习例子</h3>
<p>抽象工厂可以理解为多维的工厂方法，一系列相互依赖的对象。例如我们实现了 GAN 和 Transformer 两种模型，为了测试我们需要在两种数据集 translation 和 paraphrase 上测试，两个 trainer 就变成了 translation+transformer，paraphrase+GAN 这样两组相互依赖的对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Translation</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">translation_pairs</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Paraphrase</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">paraphrase_lists</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于网络，如上定义两个深度学习模型 Transformer 和 GAN</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Transformer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;Transformer&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GAN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;GAN&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后，对于训练模型的 Trainer，我们需要同时实现数据集和网络两个不同维度模型的组合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Trainer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_network</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TransformerTranslationTrainer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_network</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Transformer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Translation</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GANParaphraseTrainer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_network</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GAN</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">build_dataset</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Paraphrase</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在实际的使用中，我们只需要创建一个相应的 Trainer，调用对应的训练 api 即可。</p>
<p>例如在 [[Fairseq]] 框架中，对应的 Task 就是一个很好的抽象工厂模式，它调度了模型和数据集的搭建。</p>
<h2 id="生成器-builder">生成器 Builder</h2>
<p></p>
<ul>
<li>生成器 Builder 接口声明所有类型生成器中通用的产品构造步骤</li>
<li>产品是最终生成的对象</li>
<li>主管 Director 定义调用构造步骤的顺序</li>
<li>客户端 Client 将某个生成器对象与 Director 关联</li>
</ul>
<h3 id="使用场景-2">使用场景</h3>
<ol>
<li>重叠的多种构造函数出现</li>
<li>使用代码创建不同形式的产品，过程相似细节不同</li>
<li>使用生成器构造组合树或其他复杂对象</li>
</ol>
<h3 id="效果-2">效果</h3>
<ol>
<li>分步创建对象，暂缓创建步骤</li>
<li>生成不同形式的产品，复用相同制造代码</li>
<li>单一直则原则，将复杂代码从业务逻辑分离</li>
<li>会增加多个类，代码整体复杂度增加</li>
</ol>
<h3 id="深度学习例子-2">深度学习例子</h3>
<p>例如普通分类模型，包括多种模型结构，如 Linear，MLP，CNN 等，都由 Linear 层和 Conv 层这两个基本单元构成。可以使用生成器模式来实现模型层级的搭建。</p>
<p>首先定义一个 Network 类和 Builder 类，来处理向基类中添加层</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Network</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Builder</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">addLinearLayer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">addConvLayer</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="原型-prototype">原型 Prototype</h2>
<h3 id="使用场景-3">使用场景</h3>
<h3 id="效果-3">效果</h3>
<h3 id="深度学习例子-3">深度学习例子</h3>
<h2 id="单例-singleton">单例 Singleton</h2>
<h3 id="使用场景-4">使用场景</h3>
<h3 id="效果-4">效果</h3>
<h3 id="深度学习例子-4">深度学习例子</h3>
]]></description></item><item><title>项目开发守则</title><link>https://nil-zhuang.github.io/2022/10/project_rule/</link><pubDate>Fri, 28 Oct 2022 15:06:28 +0800</pubDate><author>Nil Zhuang</author><guid>https://nil-zhuang.github.io/2022/10/project_rule/</guid><description><![CDATA[<h1 id="project_rule">project_rule</h1>
<p>本项目是南京大学软件学院 2018 级软件工程与计算 III 课程设计项目</p>
<h2 id="1-总体规约">1. 总体规约</h2>
<ol>
<li>开发工具：Intellij IDEA</li>
<li>数据库管理工具：Navicat</li>
<li>项目文档和沟通管理：飞书</li>
<li>项目版本管理工具：git</li>
<li>接口管理工具：Apifox</li>
</ol>
<h2 id="2-编程规约">2. 编程规约</h2>
<blockquote>
<p>Craftsmanship and the Problem of Productivity: Secrets for Going Fast without Making a Mess</p>
</blockquote>
<h3 id="21-代码规范">2.1 代码规范</h3>
<p>JAVA 代码规范参照 IDEA 插件 <strong>Alibaba Java Coding Guidelines</strong>，尽量减少 warning，不能存在 error</p>
<h4 id="211-软工设计原则">2.1.1 软工设计原则</h4>
<ol>
<li>
<p>单一职责原则</p>
<p>对类来说，一个类应该只负责一项职责。如果一个类负责两个职责，可能存在职责 1 变化，引起职责 2 的变化情况。可以基于抽象逻辑，或者业务逻辑对类进行细化。</p>
</li>
<li>
<p>接口隔离原则</p>
<p>客户端不应该依赖它不需要的接口，一个类对另外一个类的依赖，应该建立在最小的接口上。</p>
</li>
<li>
<p>依赖倒置原则</p>
<p>高层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中心思想是面向接口编程。</p>
</li>
<li>
<p>里氏替换原则</p>
<p>如果将所有类型为 T1 的对象 O1 都替换成类型 T2de 对象 O2，程序的行为不发生改变。那么类型 T2 是类型 T1 的子类型。换句话说说有引用基类的地方必须能透明的使用其子类的对象。</p>
</li>
<li>
<p>开闭原则</p>
<p>在代码结构的设计设计时，应该考虑对扩展开放，对修改关闭，抽象思维搭建结构，具体实现扩展细节。</p>
</li>
<li>
<p>迪米特法则</p>
<p>一个类对自己依赖的类知道的越要越好。也就是说，对于依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外开放任何信息</p>
</li>
</ol>
<h3 id="22-注释规范">2.2 注释规范</h3>
<ol>
<li><strong>代码是用来读的</strong>，代码的意图应该由代码自身阐述，优先考虑写更可读的代码</li>
<li>代码意图明显的情况下，不要加注释重复说明</li>
<li>临时注释标记：TODO, FIXME, OPTIMIZE, REVIEW</li>
<li>注释应该随着代码更新</li>
</ol>
<h4 id="221-必须要写注释的情况">2.2.1 必须要写注释的情况</h4>
<p>为什么，而非是什么</p>
<ol>
<li>纲要性的注释：简洁清晰的描述一个文件、类或一个流程</li>
<li>复杂的业务逻辑、算法</li>
<li>代码的作用不直观时，解释这样做的原因</li>
<li>存在多种可选方案时，解释这样选择的原因</li>
<li>因为某些限制导致代码不一致、不优雅、存在副作用时，注明原因及后果</li>
<li>参考了外部资料时，要注明链接方便查看</li>
<li>所有的抽象方法</li>
</ol>
<h2 id="3-日志规约">3. 日志规约</h2>
<p>使用 slf4j 框架记录项目运行日志，不要用系统原生 log</p>
<h2 id="4-测试规约">4. 测试规约</h2>
<p>AIR 原则：单元测试在运行时，要感觉像 AIR 一样并不存在 &ndash;Automatic, Independent, Repeatable</p>
<h2 id="5-安全规约">5. 安全规约</h2>
<ol>
<li>用户请求传入的任何参数必须做有效性验证，忽略参数校验可能导致
<ol>
<li>page size 过大导致内存溢出</li>
<li>恶意 order 导致数据库安全风险或慢查询</li>
</ol>
</li>
<li>用户敏感数据必须要放在数据库中，账号密码等强安全数据需要使用彩虹表等进行加密处理</li>
<li>用户传入的 SQL 参数严格使用参数绑定或 metadata 字段限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库 (还记得华为的 drop database 吗)</li>
<li>隶属于用户个人的页面或者功能必须进行权限控制校验</li>
<li>在使用平台资源 (短信、邮件、电话等) 必须实现防重复限制，如数量限制、疲劳度控制、验证码校验等，避免被滥用</li>
</ol>
<h2 id="6-数据库规约">6. 数据库规约</h2>
<h3 id="61-建表规约">6.1 建表规约</h3>
<ol>
<li>表达是否概念的字段必须使用 is_xxx 方式命名，数据类型是 <code>unsigned tinyint</code>(1 表示是，0 表示否)</li>
<li>如果用字符串来表示有限个状态 (例如 status)，必须在后端使用枚举类型传入参数</li>
<li>表名、字段名必须使用小写字母或数字，禁止数字开头，禁止两个下划线间只有数字。数据库字段名的修改代价很大，字段名的命名需要慎重考虑。
<ul>
<li>Mysql 在 Windows 下不区分大小写，而 Linux 下默认区分，因此不允许出现任何大写字母</li>
</ul>
</li>
<li>表名不使用复数名词
<ul>
<li>表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯</li>
</ul>
</li>
<li>小数类型为 decimal，禁止使用 float 和 double
<ul>
<li>float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储</li>
</ul>
</li>
<li>如果存储的字符串长度几乎相等，使用 char 定长字符串类型</li>
<li>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率</li>
<li>表必备三字段：id, gmt_create, gmt_modified。
<ul>
<li>其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 timestamp 类型，前者现在时表示主动创建，后者过去分词表示被动更新</li>
</ul>
</li>
<li>表的命名最好以 <code>业务名称_表的作用</code> 作为开头</li>
<li>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循
<ol>
<li>不是频繁修改的字段。</li>
<li>不是 varchar 超长字段，更不能是 text 字段。</li>
</ol>
</li>
<li>所有字符的存储与表示都要以 <code>utf-8</code> 编码
<ul>
<li>字符统计函数在不同编码有区别，因此统一编码</li>
</ul>
</li>
</ol>
<h3 id="62-sql-规范">6.2 SQL 规范</h3>
<ol>
<li>不要使用 <code>count(列名)</code> 或 <code>count(常量)</code> 来替代 <code>count(*)</code>，<code>count</code> 是统计行数的语法，和数据库无关，和 NULL 非 NULL 无关
<ul>
<li><code>count(*)</code> 会统计值为 NULL 的行，而 <code>count(列名)</code> 不会统计为 NULL 的行</li>
</ul>
</li>
<li>使用 <code>ISNULL()</code> 来判断是否为 NULL，因为 <code>NULL&lt;&gt;NULL, NULL=NULL, NULL&lt;&gt;1</code> 的结果都是 NULL 而不是 true</li>
</ol>
<h2 id="7-版本控制规约">7. 版本控制规约</h2>
<p>乱动 origin/main 者，狗头打掉！</p>
<blockquote>
<p><a href="https://ourai.ws/posts/working-with-git-in-team/" target="_blank" rel="noopener noreffer ">git团队实践</a>
<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener noreffer ">阮一峰git规范</a></p>
</blockquote>
<h3 id="71-commit-规则">7.1 Commit 规则</h3>
<ol>
<li>commit 记录以 commit 类型作为开头：
<ol>
<li>feat 新特性</li>
<li>fix bug 修复</li>
<li>hotfix 对生产代码的紧急修复</li>
<li>docs 文档改动</li>
<li>style 格式化</li>
<li>refactor 重构代码</li>
<li>test 项目测试</li>
</ol>
</li>
<li>commit 的粒度是一个小功能点或一个 bugfix，将恢复的误伤操作降到最低</li>
<li>commit 记录中，用一句简练的话概括，然后空一行阐述提交增加或修改的地方</li>
<li>commit 要有独立性，如果是多个功能相同或相近的 commit 可以使用 rebase -i 合并或调整；如果是对上一个 commit 的修正可以用 amend 修复；<strong>禁止无意义的 commit</strong></li>
<li>如果有临时但暂时不需要提交的改动，可以用 stash 暂存代码</li>
<li>在有多个 commit，功能开发到达一个里程碑节点或是完成功能再 push，以整洁 origin/master，尽可能一个 push 就是一个 feat</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">    feat: 完成用户注册接口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    UserController 添加了用户注册接口 /user/register
</span></span><span class="line"><span class="cl">    UserService 用户注册接口 userRegister(UserVO)，用户密码提供了彩虹表校验
</span></span><span class="line"><span class="cl">    UserMapper  userRegister(UserPO)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="72-开发规则">7.2 开发规则</h3>
<p>我们需要一个干净整洁的 work tree</p>
<ol>
<li>所有的项目开发都会在 dev 分支上进行，生产代码会保留在 master 分支上，非 hotfix 等紧急情况禁止向 master 分支提交</li>
<li>所有新 feature 的开发都需要建立一个新的、以该 feature 命名的分支，然后在该分支上进行提交后，将其 <code>merge</code> 到 dev 分支上</li>
<li>项目更新一律使用 rebase，即 <code>git pull --rebase</code></li>
</ol>
<h3 id="73-其余规范">7.3 其余规范</h3>
<ol>
<li>谁提交了.idea 或者.vscode 文件夹，谁请喝奶茶</li>
</ol>
]]></description></item></channel></rss>